{"version":3,"sources":["utils/url.ts","utils/crypto.ts","network/peerUtils.ts","components/ErrorFallback.tsx","components/SuspenseFallback.tsx","components/SingleRoomEntrance.tsx","components/GitHubCorner.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["copyHashFromLink","link","srcHash","URL","hash","slice","srcSearchParams","URLSearchParams","dstHash","window","location","dstSearchParams","forEach","value","key","set","toString","e","extractRoomIdFromLink","get","getRoomIdFromUrl","setRoomIdToUrl","roomId","searchParams","getServerConfigFromUrl","server","url","secure","protocol","defaultPort","host","split","port","Number","path","pathname","secureRandomId","len","buf","crypto","getRandomValues","Uint8Array","arr","Array","from","hex","map","b","padStart","join","rand4","Uint16Array","generateCryptoKey","a","subtle","generateKey","name","length","exportKey","importCryptoKey","usages","size","i","parseInt","importKey","cryptoKey","encrypt","data","encoder","TextEncoder","iv","encode","encrypted","byteLength","decrypt","decrypted","decoder","TextDecoder","decode","ROOM_ID_PREFIX_LEN","isValidPeerId","peerId","startsWith","generatePeerId","peerIndex","getPeerIndexFromPeerId","getPeerIndexFromConn","conn","peer","createConnectionMap","Map","addConn","close","mediaTypes","markConnected","connected","isConnected","setUserId","userId","getUserId","setMediaTypes","getMediaTypes","hasConn","has","delConn","delete","getConnectedPeerIds","keys","filter","k","forEachConnectedConns","callback","values","forEachConnsAcceptingMedia","mediaType","includes","clearAll","console","log","clear","ErrorFallback","React","memo","err","useState","waitSec","setWaitSec","useEffect","setTimeout","reload","message","SuspenseFallback","className","Landing","lazy","SingleRoom","roomIdFromUrl","SingleRoomEntrance","setRoomId","linkShown","setLinkShown","linkText","setLinkText","onCreateNew","type","onClick","onChange","target","placeholder","disabled","GitHubCorner","fill","color","href","aria-label","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","ErrorBoundary","state","children","this","props","PureComponent","App","fallback","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.15888c68.chunk.js","sourcesContent":["export const copyHashFromLink = (link: string) => {\n  try {\n    const srcHash = new URL(link).hash.slice(1);\n    const srcSearchParams = new URLSearchParams(srcHash);\n    const dstHash = window.location.hash.slice(1);\n    const dstSearchParams = new URLSearchParams(dstHash);\n    srcSearchParams.forEach((value, key) => {\n      dstSearchParams.set(key, value);\n    });\n    window.location.hash = dstSearchParams.toString();\n  } catch (e) {\n    // ignore\n  }\n};\n\nexport const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n\nexport const getServerConfigFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const server = searchParams.get(\"server\");\n  try {\n    const url = new URL(server || \"\");\n    const secure = url.protocol === \"https:\";\n    const defaultPort = secure ? 443 : 80;\n    return {\n      host: url.host.split(\":\")[0],\n      port: url.port ? Number(url.port) : defaultPort,\n      path: url.pathname,\n      secure,\n    };\n  } catch (e) {\n    // ignore\n  }\n  return null;\n};\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = (len = 32) => {\n  const buf = window.crypto.getRandomValues(new Uint8Array(len));\n  const arr = Array.from(buf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n\nexport const generateCryptoKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  );\n  const buf = await window.crypto.subtle.exportKey(\"raw\", key);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const importCryptoKey = async (\n  key: string,\n  usages: (\"encrypt\" | \"decrypt\")[]\n) => {\n  const size = key.length / 2;\n  const buf = new Uint8Array(size);\n  for (let i = 0; i < size; i += 1) {\n    buf[i] = parseInt(key.slice(i * 2, i * 2 + 2), 16);\n  }\n  const cryptoKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    buf,\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    usages\n  );\n  return cryptoKey;\n};\n\nexport const encrypt = async (data: string, key: string) => {\n  const encoder = new TextEncoder();\n  const cryptoKey = await importCryptoKey(key, [\"encrypt\"]);\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encrypted = await window.crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv },\n    cryptoKey,\n    encoder.encode(data)\n  );\n  const buf = new Uint8Array(iv.length + encrypted.byteLength);\n  buf.set(iv);\n  buf.set(new Uint8Array(encrypted), iv.length);\n  return buf;\n};\n\nexport const decrypt = async (buf: ArrayBuffer, key: string) => {\n  const cryptoKey = await importCryptoKey(key, [\"decrypt\"]);\n  const decrypted = await window.crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: buf.slice(0, 12) },\n    cryptoKey,\n    buf.slice(12)\n  );\n  const decoder = new TextDecoder(\"utf-8\");\n  const data = decoder.decode(new Uint8Array(decrypted));\n  return data;\n};\n","import Peer from \"peerjs\";\n\nexport const ROOM_ID_PREFIX_LEN = 32;\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, mediaTypes: [] });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setMediaTypes = (conn: Peer.DataConnection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (\n        value.connected &&\n        value.mediaTypes &&\n        value.mediaTypes.includes(mediaType)\n      ) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setMediaTypes,\n    getMediaTypes,\n    hasConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n  };\n};\n","import React, { useEffect, useState } from \"react\";\n\nexport const ErrorFallback = React.memo<{\n  err: Error;\n}>(({ err }) => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      {err && (\n        <h6>\n          {err.name}: {err.message}\n        </h6>\n      )}\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./SuspenseFallback.css\";\n\nexport const SuspenseFallback = React.memo(() => (\n  <div className=\"Loading-container\">\n    <div>Loading...</div>\n  </div>\n));\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId, generateCryptoKey } from \"../utils/crypto\";\nimport { ROOM_ID_PREFIX_LEN } from \"../network/peerUtils\";\nimport {\n  getRoomIdFromUrl,\n  extractRoomIdFromLink,\n  copyHashFromLink,\n} from \"../utils/url\";\n\nconst Landing = React.lazy(() => import(\"./Landing\"));\nconst SingleRoom = React.lazy(() => import(\"./SingleRoom\"));\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nexport const SingleRoomEntrance = React.memo(() => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkShown, setLinkShown] = useState(false);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = async () => {\n    setRoomId(\n      secureRandomId(ROOM_ID_PREFIX_LEN / 2) + (await generateCryptoKey())\n    );\n  };\n\n  const onEnter = () => {\n    copyHashFromLink(linkText);\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-container\">\n      <Landing>\n        <div className=\"SingleRoomEntrance-input\">\n          {!linkShown && (\n            <>\n              <div>\n                <button type=\"button\" onClick={onCreateNew}>\n                  Create a new room\n                </button>\n              </div>\n              <div className=\"SingleRoomEntrance-or\">OR</div>\n              <div>\n                <button type=\"button\" onClick={() => setLinkShown(true)}>\n                  Enter an existing room link\n                </button>\n              </div>\n            </>\n          )}\n          {linkShown && (\n            <div>\n              <input\n                value={linkText}\n                onChange={(e) => setLinkText(e.target.value)}\n                placeholder=\"Enter room link...\"\n              />\n              <button\n                type=\"button\"\n                onClick={onEnter}\n                disabled={!extractRoomIdFromLink(linkText)}\n              >\n                Enter room\n              </button>\n              <button type=\"button\" onClick={() => setLinkShown(false)}>\n                Cancel\n              </button>\n            </div>\n          )}\n        </div>\n      </Landing>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\n// http://tholman.com/github-corners/\nexport const GitHubCorner = React.memo<{\n  size?: number;\n  fill?: string;\n  color?: string;\n}>(({ size, fill, color }) => (\n  <a\n    href=\"https://github.com/dai-shi/remote-faces\"\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n));\n","import React, { Suspense } from \"react\";\n\nimport \"./App.css\";\nimport { ErrorFallback } from \"./ErrorFallback\";\nimport { SuspenseFallback } from \"./SuspenseFallback\";\nimport { SingleRoomEntrance } from \"./SingleRoomEntrance\";\nimport { GitHubCorner } from \"./GitHubCorner\";\n\nclass ErrorBoundary extends React.PureComponent {\n  state: { err?: Error } = {};\n\n  static getDerivedStateFromError(err: Error) {\n    return { err };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { err } = this.state;\n    if (err) return <ErrorFallback err={err} />;\n    return children;\n  }\n}\n\nexport const App = React.memo(() => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <Suspense fallback={<SuspenseFallback />}>\n        <SingleRoomEntrance />\n        <GitHubCorner size={40} fill=\"gray\" />\n      </Suspense>\n    </ErrorBoundary>\n  </div>\n));\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}