{"version":3,"sources":["media/screen.ts","hooks/useScreenShare.ts","components/ScreenShare.tsx"],"names":["getScreenStream","a","constraints","video","navigator","mediaDevices","getDisplayMedia","stream","getVideoTracks","track","dispose","stop","isScreenTrack","kind","isVideoTrackFaceSize","isFaceSize","Screen","React","memo","nickname","videoRef","useRef","useEffect","current","srcObject","className","ref","autoPlay","muted","ScreenShare","roomId","userId","useState","enabled","setEnabled","screenStream","setScreenStream","screenStreamMap","setScreenStreamMap","cleanupFns","forEach","fn","onTrack","useCallback","info","prev","MediaStream","onended","addEventListener","push","removeEventListener","useRoomMedia","addTrack","removeTrack","result","useScreenShare","nicknameMap","useNicknameMap","type","onClick","Object","keys","map","screenUserId","key"],"mappings":"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","file":"static/js/8.3d00e3ef.chunk.js","sourcesContent":["export const getScreenStream = async () => {\n  try {\n    const constraints = { video: true };\n    const stream = (await (navigator.mediaDevices as any).getDisplayMedia(\n      constraints\n    )) as MediaStream;\n    const [track] = stream.getVideoTracks();\n    const dispose = () => {\n      track.stop();\n    };\n    return {\n      stream,\n      dispose,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { isVideoTrackFaceSize } from \"../media/video\";\nimport { getScreenStream } from \"../media/screen\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst isScreenTrack = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") return false;\n  const isFaceSize = await isVideoTrackFaceSize(track);\n  return !isFaceSize;\n};\n\nexport const useScreenShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void\n) => {\n  const [screenStream, setScreenStream] = useState<MediaStream | null>(null);\n  const [screenStreamMap, setScreenStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (!(await isScreenTrack(track))) return;\n    setScreenStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setScreenStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  }, []);\n\n  const { addTrack, removeTrack } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    \"screenVideo\"\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (enabled && addTrack && removeTrack) {\n      (async () => {\n        const result = await getScreenStream();\n        if (!result) {\n          setEnabled(false);\n          return;\n        }\n        const [track] = result.stream.getVideoTracks();\n        addTrack(track);\n        setScreenStream(result.stream);\n        dispose = () => {\n          removeTrack(track);\n          result.dispose();\n          setScreenStream(null);\n          setEnabled(false);\n        };\n        track.addEventListener(\"ended\", () => {\n          if (dispose) dispose();\n          dispose = null;\n        });\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, enabled, setEnabled, addTrack, removeTrack]);\n\n  return { screenStream, screenStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./ScreenShare.css\";\nimport { useScreenShare } from \"../hooks/useScreenShare\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Screen = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"ScreenShare-nickname\">{nickname}</div>\n      <video className=\"ScreenShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\nexport const ScreenShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const [enabled, setEnabled] = useState(false);\n  const { screenStream, screenStreamMap } = useScreenShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n\n  return (\n    <div className=\"ScreenShare-container\">\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop screen share\" : \"Start screen share\"}\n      </button>\n      {screenStream && <Screen nickname={nickname} stream={screenStream} />}\n      {Object.keys(screenStreamMap).map((screenUserId) => {\n        const stream = screenStreamMap[screenUserId];\n        if (!stream) return null;\n        return (\n          <Screen\n            key={screenUserId}\n            nickname={nicknameMap[screenUserId] || \"No Name\"}\n            stream={stream}\n          />\n        );\n      })}\n    </div>\n  );\n});\n\nexport default ScreenShare;\n"],"sourceRoot":""}